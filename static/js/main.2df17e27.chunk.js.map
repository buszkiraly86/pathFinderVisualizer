{"version":3,"sources":["PathFinder.js","serviceWorker.js","index.js"],"names":["Cell","i","j","distance","this","fixed","PathFinder","props","startingPoint","Math","floor","rows","destinationPoint","state","clean","finding","board","_generateBoard","columns","row","Infinity","push","update","frontier","updateFrontier","wall","neighbor","min","fixCell","cell","length","minFrontier","splice","Promise","res","setTimeout","console","log","head","next","position","path","setState","_dijkstra","down","mouseDown","_setWall","className","key","onMouseDown","_mouseDownHandler","onMouseUp","onMouseEnter","onMouseLeave","width","disabled","onClick","a","_reset","_find","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.2df17e27.chunk.js","sourcesContent":["import React from 'react';\nimport './PathFinder.css';\n\nclass Cell {\n    \n    constructor(i, j, distance) {\n        this.i = i;\n        this.j = j;\n        this.distance = distance;\n        this.fixed = false;\n    }\n}\n\nclass PathFinder extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.props = props;\n        this.startingPoint = [Math.floor(this.props.rows / 2), 8];\n        this.destinationPoint = [Math.floor(this.props.rows / 2), 41];\n        this.state = {\n            clean: true,\n            finding: false,\n            board: this._generateBoard(this.props.rows, this.props.columns)\n        }\n    }\n\n    _generateBoard(rows, columns) {\n        const board = [];\n\n        for (let i = 0; i < rows; ++i) {\n            const row = [];\n\n            for (let j = 0; j < columns; ++j) {\n\n                let distance = Infinity;\n\n                if (i === this.startingPoint[0] && j === this.startingPoint[1]) {\n                    distance = 0;\n                }\n\n                row.push(new Cell(i, j, distance));\n            }\n\n            board.push(row);\n        }\n\n        return board;\n    }\n\n    async _dijkstra(board, update) {\n        const frontier = [];\n\n        const updateFrontier = (i, j, distance) => {\n            if (i >= 0 && i < this.props.rows && j >= 0 && j < this.props.columns && !board[i][j].fixed && !board[i][j].wall) {\n                let neighbor = board[i][j];\n                if (neighbor.frontier) {\n                    neighbor.distance = Math.min(neighbor.distance, distance + 1);\n                } else {\n                    neighbor.distance = distance + 1;\n                    neighbor.frontier = true;\n                    frontier.push(neighbor);\n                }\n            }\n        }\n\n        const fixCell = (cell) => {\n            let i = cell.i;\n            let j = cell.j;\n\n            updateFrontier(i - 1, j, cell.distance);\n            updateFrontier(i + 1, j, cell.distance);\n            updateFrontier(i, j - 1, cell.distance);\n            updateFrontier(i, j + 1, cell.distance);\n\n            cell.fixed = true;\n            cell.frontier = false;\n        }\n\n        fixCell(board[this.startingPoint[0]][this.startingPoint[1]]);\n\n        while (frontier.length && !board[this.destinationPoint[0]][this.destinationPoint[1]].fixed) {\n            let minFrontier = 0;\n\n            for (let i = 1; i < frontier.length; ++i) {\n                if (frontier[minFrontier].distance > frontier[i].distance) {\n                    minFrontier = i;\n                }\n            }\n\n            fixCell(frontier[minFrontier]);\n            frontier.splice(minFrontier, 1);\n\n            await new Promise(res => setTimeout(res, 10));\n            update(board);\n        }\n\n        console.log(\"destination found: \", board[this.destinationPoint[0]][this.destinationPoint[1]].distance);\n        console.log(\"start backtracking...\");\n\n        let head = board[this.destinationPoint[0]][this.destinationPoint[1]];\n        while (head.i !== this.startingPoint[0] || head.j !== this.startingPoint[1]) {\n            let positions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n            let next = head;\n\n            for (const position of positions) {\n                const i = head.i + position[0];\n                const j = head.j + position[1];\n\n                if (i >= 0 && i < this.props.rows && j >= 0 && j < this.props.columns && board[i][j].fixed && board[i][j].distance < next.distance) {\n                    next = board[i][j];\n                }\n            }\n\n            await new Promise(res => setTimeout(res, 100));\n            next.path = true;\n            head = next;\n            update(board);\n        }\n\n    }\n\n    async _reset() {\n        const state = {\n            clean: true,\n            finding: false,\n            board: this._generateBoard(this.props.rows, this.props.columns)\n        }\n\n        this.setState(state);\n    }\n\n    async _find() {\n        const state = {...this.state}; \n        state.finding = true;\n        state.clean = false;\n        this.setState(state);\n\n        await this._dijkstra([...this.state.board], (board) => {\n            state.board = [...board];\n            this.setState(state);\n        });\n\n        state.finding = false;\n        this.setState(state);\n    }\n\n    _setWall(i, j, down) {\n        if (!down) return;\n\n        const state = {...this.state};\n        state.board[i][j].wall = !state.board[i][j].wall;\n\n        this.setState(state);\n    }\n\n    _mouseDownHandler(down, i, j) {\n        const state = {...this.state}\n        state.mouseDown = down;\n\n        this._setWall(i, j, down);\n\n        this.setState(state);\n    }\n\n    render() {\n        const rows = [];\n\n        for (let i = 0; i < this.state.board.length; ++i) {\n            const row = [];\n            for (let j = 0; j < this.state.board[i].length; ++j) {\n                let className = \"\";\n                const key = i * this.state.board[i].length + j;\n\n                if (this.state.board[i][j].frontier) {\n                    className = \"frontier\";\n                }\n\n                if (this.state.board[i][j].fixed) {\n                    className = \"fixed\";\n                }\n\n                if (this.state.board[i][j].wall) {\n                    className = \"wall\";\n                }\n\n                if (this.state.board[i][j].path) {\n                    className = \"path\";\n                }\n\n                if (i === this.startingPoint[0] && j === this.startingPoint[1]) {\n                    className = \"startingPoint\";\n                }\n\n                if (i === this.destinationPoint[0] && j === this.destinationPoint[1]) {\n                    className = \"destinationPoint\";\n                }\n\n                row.push(\n                    <td\n                        onMouseDown={() => this._mouseDownHandler(true, i, j)}\n                        onMouseUp={() => this._mouseDownHandler(false)}\n                        onMouseEnter={() => this._setWall(i, j, this.state.mouseDown)}\n                        className={className}\n                        key={key}>\n                    </td>); \n            }\n            rows.push(\n                <tr key={i}>\n                    {row}\n                </tr>\n            );\n        }\n\n        return (\n            <div className=\"PathFinder\">\n                <div className=\"Board\">\n                    <table onMouseLeave={() => this._mouseDownHandler(false)} width=\"500px\">\n                        <tbody>\n                            {rows}\n                        </tbody>\n                    </table>\n                </div>\n                <div className=\"finderBtnRow\">\n                    <button className=\"finderBtn\" disabled={this.state.finding} onClick={async () => await this._reset()}>Reset</button>\n                    <button className=\"finderBtn\" disabled={this.state.finding || !this.state.clean} onClick={async () => await this._find()}>Dijkstra</button>\n                    <p>\n                        walls can be erected by using the mouse\n                    </p>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default PathFinder;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport PathFinder from './PathFinder';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathFinder rows={25} columns={50} />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}